<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Using smoltcp RPL</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <link href='https://fonts.googleapis.com/css?family=JetBrains Mono' rel='stylesheet'>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Using smoltcp</li><li class="chapter-item expanded "><a href="using_smoltcp.html"><strong aria-hidden="true">1.</strong> Setting up a basic stack</a></li><li class="chapter-item expanded "><a href="adding_sockets.html"><strong aria-hidden="true">2.</strong> Adding sockets</a></li><li class="chapter-item expanded "><a href="adding_rpl.html"><strong aria-hidden="true">3.</strong> Adding RPL</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Adding DNS</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Protocols</li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 6LoWPAN</div></li><li class="chapter-item expanded "><a href="rpl_introduction.html"><strong aria-hidden="true">6.</strong> RPL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mop0.html"><strong aria-hidden="true">6.1.</strong> MOP0</a></li><li class="chapter-item expanded "><a href="mop1.html"><strong aria-hidden="true">6.2.</strong> MOP1</a></li><li class="chapter-item expanded "><a href="mop2.html"><strong aria-hidden="true">6.3.</strong> MOP2</a></li><li class="chapter-item expanded "><a href="mop3.html"><strong aria-hidden="true">6.4.</strong> MOP3</a></li><li class="chapter-item expanded "><a href="rpl-msg-formats.html"><strong aria-hidden="true">6.5.</strong> Control Message Formats</a></li><li class="chapter-item expanded "><a href="rpl-optimizations.html"><strong aria-hidden="true">6.6.</strong> Optimizations</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="about.html">About</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Using smoltcp RPL</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<pre><code class="language-admonish warning">This website is still under construction.
</code></pre>
<pre><code class="language-admonish danger title=&quot;Experimental RPL implementation&quot;">RPL support is not yet available in the main branch of smoltcp.
The current RPL implementation is available in the `rpl` branch of smoltcp.
Note that the RPL implementation is still experimental and not yet ready for production.
</code></pre>
<p>The <a href="https://datatracker.ietf.org/doc/html/rfc6550">Routing Protocol for Low-power and lossy networks (RPL)</a>
is a routing protocol for low power and lossy networks (LLNs).
It is designed to be used in various application domains such as industrial monitoring,
building automation, connected homes, and smart cities.
RPL is a distance vector routing protocol that builds a Directed Acyclic Graph (DAG) connecting the nodes in the network.
The DAG is used to route packets in the network.
RPL is designed to be used in networks where the nodes are constrained in terms of power, memory, and processing resources.</p>
<p>The goal of this website is to better explain how RPL works and how to use it with <a href="https://github.com/smoltcp-rs/smoltcp">smoltcp</a>.
At the moment, the RPL implementation can be found in the <a href="https://github.com/thvdveld/smoltcp/tree/rpl"><code>rpl</code> branch</a> of smoltcp.</p>
<h2 id="implementations-of-rpl"><a class="header" href="#implementations-of-rpl">Implementations of RPL</a></h2>
<p>Contiki-NG is an open-source operating system for the Internet of Things.
It is a fork of the Contiki operating system and supports a wide range of platforms.
Contiki-NG includes an implementation of RPL.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-smoltcp"><a class="header" href="#using-smoltcp">Using smoltcp</a></h1>
<h2 id="1-adding-smoltcp-to-your-cargotoml"><a class="header" href="#1-adding-smoltcp-to-your-cargotoml">1. Adding <code>smoltcp</code> to your <code>Cargo.toml</code></a></h2>
<p>To use <code>smoltcp</code> in your project, you must add it as a dependency in the <code>Cargo.toml</code> file.
<code>smoltcp</code> uses a lot of feature flags for configuration and therefore the correct ones need to be added.</p>
<p>Depending on the medium that is used, at least one of the following features must be enabled:</p>
<ul>
<li><code>medium-ethernet</code> for Ethernet devices;</li>
<li><code>medium-ieee802154</code> for IEEE802.15.4 devices. Enabling this feature, also enables <code>proto-sixlowpan</code>;</li>
<li><code>medium-ip</code> for devices without medium.</li>
</ul>
<p>For the network layer, at least one of the following features must be enabled:</p>
<ul>
<li><code>proto-ipv4</code> for IPv4;</li>
<li><code>proto-ipv6</code> for IPv6;</li>
<li><code>proto-sixlowpan</code> for 6LoWPAN.</li>
</ul>
<p>There are many more feature flags that can be enabled.
For more information, see the <a href="https://docs.rs/smoltcp/latest/smoltcp/#feature-flags">documentation</a>.</p>
<pre><code class="language-admonish example title=&quot;Example: IEEE802.15.4 device using 6LoWPAN and RPL&quot;">For a IEEE802.15.4 device using 6LoWPAN and RPL, the following is added in the `Cargo.toml` file:

```toml
[dependencies.smoltcp]
version = &quot;0.10&quot;
default-features = false
features = [
	&quot;medium-ieee802154&quot;,
	&quot;proto-sixlowpan&quot;,
	&quot;rpl-mop-2&quot;
]
```

This will use RPL with MOP 2 (Storing Mode of Operation) and 6LoWPAN with the IEEE802.15.4 medium.
These are the available modes of operation: `rpl-mop-0`, `rpl-mop-1`, `rpl-mop-2` and `rpl-mop-3`.
</code></pre>
<h2 id="2-implementing-smoltcpphydevice-for-your-platform"><a class="header" href="#2-implementing-smoltcpphydevice-for-your-platform">2. Implementing <code>smoltcp::phy::Device</code> for your platform</a></h2>
<p>In order for <code>smoltcp</code> to effectively handle incoming and outgoing packets, 
a connection must be established between the TCP/IP stack and the underlying hardware.
This essential linkage is achieved by implementing the <a href="https://docs.rs/smoltcp/latest/smoltcp/phy/trait.Device.html"><code>smoltcp::phy::Device</code></a>
trait for the hardware:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate smoltcp;
</span><span class="boring">use smoltcp::phy::DeviceCapabilities;
</span>pub trait RxToken {
    fn consume&lt;R, F&gt;(self, f: F) -&gt; R
    where
        F: FnOnce(&amp;mut [u8]) -&gt; R;
}

pub trait TxToken {
    fn consume&lt;R, F&gt;(self, len: usize, f: F) -&gt; R
    where
        F: FnOnce(&amp;mut [u8]) -&gt; R;
}

pub trait Device {
    type RxToken&lt;'a&gt;: RxToken
    where
        Self: 'a;
    type TxToken&lt;'a&gt;: TxToken
    where
        Self: 'a;

    fn receive(&amp;mut self, timestamp: Instant) -&gt; Option&lt;(Self::RxToken&lt;'_&gt;, Self::TxToken&lt;'_&gt;)&gt;;

    fn transmit(&amp;mut self, timestamp: Instant) -&gt; Option&lt;Self::TxToken&lt;'_&gt;&gt;;

    fn capabilities(&amp;self) -&gt; DeviceCapabilities;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="3-setting-up-the-smoltcp-stack"><a class="header" href="#3-setting-up-the-smoltcp-stack">3. Setting up the <code>smoltcp</code> stack</a></h2>
<p>Once you have the <code>Device</code> trait implemented, an <a href="https://docs.rs/smoltcp/latest/smoltcp/iface/struct.Interface.html"><code>Interface</code></a> can be created.
The <code>Interface</code> is the main entry point for the <code>smoltcp</code> stack.
It is responsible for handling incoming and outgoing packets, as well as managing the sockets.
The <code>Interface</code> is created by passing a <a href="https://docs.rs/smoltcp/latest/smoltcp/iface/struct.Config.html"><code>Config</code></a>
and a <code>Device</code> to the <a href="https://docs.rs/smoltcp/latest/smoltcp/iface/struct.Interface.html#method.new"><code>new</code></a> function.
The <code>Config</code> struct contains all the configuration options for the stack.
The <code>MyDevice</code> is the hardware abstraction layer that was implemented in the previous step.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate smoltcp;
</span>use smoltcp::wire::*;
use smoltcp::iface::{Interface, Config};
use smoltcp::socket::{SocketSet, SocketStorage};

fn main() {
    // Get the MAC address from the device:
    let mac_adddr = 
        Ieee802154Address::Extended([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);

    // Create the device:
    let mut device = MyDevice::new(mac_adddr);

    // Create the configuration for the stack:
    let mut config = Config::new(mac_addr.into());
    config.pan_id = Some(Ieee802154Pan(0xbeef));

    // Create the sockets:
    let mut sockets_buffer = [SocketStorage::EMPTY; 1];
    let mut sockets = SocketSet::new(&amp;mut sockets_buffer[..]);

    // Create the interface:
    let mut iface = Interface::new(config, device)?;
}</code></pre></pre>
<h2 id="4-polling-the-smoltcp-stack"><a class="header" href="#4-polling-the-smoltcp-stack">4. Polling the <code>smoltcp</code> stack</a></h2>
<p>The interface is now ready to be used.
Polling the interface will handle incoming and outgoing packets.
For the interface to continue working, it must be polled regularly.
This is done by calling the <a href="https://docs.rs/smoltcp/latest/smoltcp/iface/struct.Interface.html#method.poll"><code>poll</code></a>
function on the interface.
If a packet is received, it is queued by the device and can be handled by the stack.
After processing the packet, the stack might have to send a packet.</p>
<p>Calling <code>poll_at</code> on the interface returns the time when the next <code>poll</code> should be called.
Calling <code>poll</code> before that time is only wasting energy, but is not harmful for the stack.
Calling <code>poll</code> after that duration might be harmful for the stack.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
	iface.poll(now, device, sockets);

	match iface.poll_at(Instant::now()) {
		Some(Instant::ZERO) =&gt; continue,
		Some(d) =&gt; sleep(d),
		None =&gt; sleep_until_new_packet(),
	}
}

<span class="boring">}</span></code></pre></pre>
<h2 id="5-youre-all-set--for-now"><a class="header" href="#5-youre-all-set--for-now">5. You're all set 🎉 (for now)</a></h2>
<p>That's it! There is nothing more that needs to be done!
The <code>smoltcp</code> stack will now handle all incoming and outgoing packets.
The next step is to create sockets and use them to send and receive data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-sockets"><a class="header" href="#adding-sockets">Adding sockets</a></h1>
<p>In the previous section, we created device with an interface.
We already used a <code>SocketSet</code>, however, this one was empty.
Let's create a <code>TcpSocket</code> and add it to the <code>SocketSet</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut sockets = SocketSet::new(vec![]);

let tcp_socket = TcpSocket::new(
    TcpSocketBuffer::new(vec![0;1500]),
    TcpSocketBuffer::new(vec![0;1500]),
);

let tcp_handle = sockets.add(tcp_socket);
<span class="boring">}</span></code></pre></pre>
<p>Now, we can use the <code>TcpSocket</code> to connect to a remote host:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let remote_addr = Ipv6Address::new(0xfe80, 0, 0, 0, 0, 0, 0, 2);
let remote_port = 4242;
let host_port = 4343;

let socket = socket.get_mut::&lt;tcp::Socket&gt;(tcp_handle);
socket.connect(iface.context(), (remote_addr, remote_port), host_port).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>The <code>TcpSocket</code> will now try to connect to the remote host.
However, we still need to poll the interface to make sure that the <code>TcpSocket</code> can send and receive packets.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    if let Err(e) = iface.poll(&amp;mut sockets, Instant::now()) {
        println!(&quot;Network error: {:?}&quot;, e);
        continue;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>TcpSocket</code> is now ready to send and receive data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    if let Err(e) = iface.poll(&amp;mut sockets, Instant::now()) {
        println!(&quot;Network error: {:?}&quot;, e);
        continue;
    }

    let mut socket = sockets.get::&lt;TcpSocket&gt;(tcp_handle);
    
    if !socket.is_open() {
        println!(&quot;Connection closed&quot;);
        break;
    }
    
    if socket.can_send() {
        socket.send_slice(b&quot;Hello world!&quot;).unwrap();
    }
    
    if socket.can_recv() {
        let data = socket.recv(|data| {
            println!(&quot;Received data: {:?}&quot;, data);
            (data.len(), data)
        }).unwrap();
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="other-socket-types"><a class="header" href="#other-socket-types">Other socket types</a></h2>
<p>The <a href="https://docs.rs/smoltcp/latest/smoltcp/socket/tcp/struct.Socket.html"><code>TcpSocket</code></a> is not the only socket type available.
There are also the following types:</p>
<ul>
<li><a href="https://docs.rs/smoltcp/latest/smoltcp/socket/dhcpv4/struct.Socket.html"><code>Dhcpv4Socket</code></a>: a DHCPv4 client socket;</li>
<li><a href="https://docs.rs/smoltcp/latest/smoltcp/socket/udp/struct.Socket.html"><code>UdpSocket</code></a>: a UDP socket;</li>
<li><a href="https://docs.rs/smoltcp/latest/smoltcp/socket/dns/struct.Socket.html"><code>DnsSocket</code></a>: a DNS client socket;</li>
<li><a href="https://docs.rs/smoltcp/latest/smoltcp/socket/icmp/struct.Socket.html"><code>IcmpSocket</code></a>: an ICMP socket.
This socket type is used to send and receive ICMP packets and might listen for specific ICMP error messages related to a UDP/TCP port;</li>
<li><a href="https://docs.rs/smoltcp/latest/smoltcp/socket/raw/struct.Socket.html"><code>RawSocket</code></a>: a raw socket.
This socket type is used to send and receive raw packets.</li>
</ul>
<pre><code class="language-admonish note title=&quot;Feature flags&quot;">Every socket type requires to enable the corresponding feature.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-rpl"><a class="header" href="#adding-rpl">Adding RPL</a></h1>
<p>To enable RPL, one of the following feature flags must be enabled:</p>
<ul>
<li><code>rpl-mop-0</code>: Enables RPL in only upward messages (MOP0);</li>
<li><code>rpl-mop-1</code>: Enables RPL in non-storing mode (MOP1);</li>
<li><code>rpl-mop-2</code>: Enables RPL in storing mode (MOP2);</li>
<li><code>rpl-mop-3</code>: Enables RPL in storing mode with multicast (MOP3).</li>
</ul>
<p>When enabling one of these feature flags, it is required to add a RPL configuration to the the interface.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use smoltcp::iface::{Interface, Config, RplConfig, RplModeOfOperation};

let mut config = Config::new(mac_addr.into());
config.rpl = RplConfig::new(RplModeOfOperation::StoringMode);
<span class="boring">}</span></code></pre></pre>
<p>For a RPL root node, the root configuration must be added:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut config = Config::new(mac_addr.into());
config.rpl = RplConfig::new(RplModeOfOperation::StoringMode).add_root_config(
    RplRootConfig::new(
        RplInstanceId::new(30),                         // Instance ID
        Ipv6Address::new(0xfd00, 0, 0, 0, 0, 0, 0, 1),  // DODAG ID
    )
);
<span class="boring">}</span></code></pre></pre>
<h2 id="thats-it-the-interface-is-now-using-rpl-"><a class="header" href="#thats-it-the-interface-is-now-using-rpl-">That's it! The interface is now using RPL 🎉</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpl"><a class="header" href="#rpl">RPL</a></h1>
<p>Routing Protocol for Low-Power and lossy networks (RPL), defined in <a href="">RFC 6550</a>,
is a routing protocol for Low-Power and Lossy Networks (LLNs)
These networks are characterized by:</p>
<ul>
<li>low bandwidth;</li>
<li>high packet loss rates;</li>
<li>hgih latency.</li>
</ul>
<p>RPL is a distance vector routing protocol that builds a
Destination Oriented Directed Acyclic Graph (DODAG) rooted at a single destination.
The DODAG is built using control messages, specifically ICMPv6 messages.
RPL supports <em>Point to Point (<strong>P2P</strong>)</em>, <em>Multipoint to Point (<strong>M2P</strong>)</em> and <em>Point to Multipoint (<strong>P2M</strong>)</em> traffic. 
<strong>P2P</strong> communication occurs between two nodes, <strong>M2P</strong> communication involves 
data being sent from multiple nodes to a central node, and <strong>P2M</strong> communication 
involves data being sent from a central node to multiple nodes.
RPL uses <strong>upward</strong> and <strong>downward routes</strong> to facilitate these different types of traffic.
Upward routes lead towards the root of the network,
while downward routes start at the root and lead towards other nodes in the network.</p>
<h4 id="destination-oriented-directed-acyclic-graph-dodag"><a class="header" href="#destination-oriented-directed-acyclic-graph-dodag">Destination Oriented Directed Acyclic Graph (DODAG)</a></h4>
<p>RPL specifies how to construct a Directed Acyclic Graph (DAG) rooted at a single destination, 
known as a Destination-Oriented DAG (DODAG), using an objective function and a set of metrics and constraints. 
The objective function evaluates a combination of metrics and constraints to determine 
the <em>best</em> path for packets to follow.</p>
<h4 id="rank"><a class="header" href="#rank">Rank</a></h4>
<p>The Rank of a node is a measure of its distance from the root node.
The rank is determined using routing metrics, which include characteristics of both the links
(such as throughput, latency, link reliability, expected transmission count, link quality level)
and the nodes (such as energy state).
These metrics are used in objective functions to calculate the cost of a route between nodes.</p>
<h4 id="parents"><a class="header" href="#parents">Parents</a></h4>
<p>The parents of a node are all its neighbors that are part of a possible route to the sink node.
A neighbor is a node that can be reached via single hop radio link.
The preferred parent of a node is the neighbor that is on the best route from the node to the sink,
depending on the objective function used.</p>
<h4 id="rpl-instance"><a class="header" href="#rpl-instance">RPL Instance</a></h4>
<p>The RPL Instance is a group of DODAGs that have the same RPL Instance ID.
All DODAGs in the same RPL Instance share the same objective function.</p>
<h4 id="dodag-id"><a class="header" href="#dodag-id">DODAG ID</a></h4>
<p>The DODAG ID is a globally unique identifier for the DODAG.
This is one of the routable IPv6 address of the root node of the DODAG.</p>
<h4 id="version-number"><a class="header" href="#version-number">Version number</a></h4>
<p>The version number is a counter that is incremented by the root node whenever a new version of the DODAG is created.</p>
<h2 id="mode-of-operations"><a class="header" href="#mode-of-operations">Mode of Operations</a></h2>
<p>RPL supports 4 mode of operations (MOPs):</p>
<ul>
<li>MOP 0: No downward routes maintained</li>
<li>MOP 1: Non-storing mode</li>
<li>MOP 2: Storing mode with no multicast supports</li>
<li>MOP 3: Storing mode with multicast support</li>
</ul>
<p>In MOP0, only upward routes are maintained.
In MOP1, MOP2 and MOP3, both upward and downward routes are maintained.
In MOP1, only the root node maintains downward routes.
In MOP2 and MOP3, all nodes maintain downward routes.
In MOP3, multicast is supported.</p>
<h2 id="control-messages"><a class="header" href="#control-messages">Control Messages</a></h2>
<p>The DODAG is created with the assistance of control messages, specifically ICMPv6 messages.
The four types of control messages that RPL uses to construct the DODAG are:</p>
<ul>
<li>DODAG Information Solicitation (<strong>DIS</strong>).</li>
<li>DODAG Information Object (<strong>DIO</strong>)</li>
<li>Destination Advertisement Object (<strong>DAO</strong>)</li>
<li>Destination Advertisement Object Acknowledgment (<strong>DAO-ACK</strong>)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mop0-no-downward-routes-maintained"><a class="header" href="#mop0-no-downward-routes-maintained">MOP0: no downward routes maintained</a></h1>
<p>In this mode of operation, the network is configured such that only upward routes are established.
This means that any node in the network can transmit messages to the root node
or any other node on its path towards the root, but not to other nodes in the network.
The default route, represented by the parent of the node,
is used to transmit data packets in an upward direction.</p>
<pre><code class="language-admonish note">In this mode of operation, **only** DIS and DIO messages are sent.
</code></pre>
<h2 id="rpl-network-formation"><a class="header" href="#rpl-network-formation">RPL network formation</a></h2>
<p>The following network contains 5 nodes.
The root node (R) and 4 normal nodes.
They are all using the same RPL Instance ID, Mode of Operation and Objective Function.</p>
<p><img src="assets/rpl/empty-network.webp" alt="Empty RPL network" />
<small>Figure 1: an empty network with 4 normal nodes and 1 root node.</small></p>
<p>The root node periodically sends a <em>DODAG Information Object (DIO)</em> packet, 
which contains information about the RPL network, more specifically about the DODAG.
The <em>DIO</em> message is sent using the <em>all-RPL-node</em> IPv6 multicast address (<code>ff02::a1</code>).
Nodes that receive this message will join the RPL network and select the root node as their parent.
These nodes will also set their rank based on the objective function and the information received in the <em>DIO</em> message.
They will also start sending <em>DIO</em> messages.</p>
<p>A node that does not hear any <em>DIO</em> message but wants to join a RPL network can send a <em>DODAG Information Solicitation (DIS)</em> message.
This message is sent to the <em>all-RPL-node</em> IPv6 multicast address (<code>ff02::a1</code>).
A node that is part of a RPL network will respond to this message with a <em>DIO</em> message.</p>
<p><img src="assets/rpl/first-dio.webp" alt="First DIO message" />
<small>
Figure 2: the root transmits a <em>DIO</em> and node 1 and 4 receive it.
Node 3 transmits a <em>DIS</em> message.
</small></p>
<p>Nodes 1 and 4 have selected the root node as their parent and have calculated their rank.
They now start to transmit <em>DIO</em> messages as well, based on the Trickle Timer algorithm.
Since node 2 and 3 are in range of node 1, they will receive the <em>DIO</em> message and join the RPL network.</p>
<p>The root node also hears the <em>DIO</em> message from node 1 and 4, however, since their rank is higher than the root node's rank,
the root node will ignore the <em>DIO</em> message.
This guarantees optimal route selection and avoids loops.</p>
<p><img src="assets/rpl/next-dio.webp" alt="Next DIO message" />
<small>
Figure 3: node 2 and 3 receive the <em>DIO</em> message from node 1 and 4 and join the RPL network.
Node 2 and 3 start sending <em>DIO</em> messages as well.
</small></p>
<p>Every node in the network now has a parent and a rank.
They will continue to send <em>DIO</em> messages based on the Trickle Timer algorithm.
Other packets, such as data packets, are sent using the default route, which is the parent of the node.
This means that data packets will always be sent in an upward direction, towards the root node.
Node 1 will never be able to send a data packet to node 4, since node 4 is not on the path towards the root node.
Neither will 3 be able to send a data packet to 2.
However, node 2 can send a data packet to node 1, since node 1 is on the path towards the root node.
This is not the use case for this mode of operation, but it is possible.
The use case for this mode of operation is to send data packets to the root node,
which collects the data and sends it to a server.</p>
<p><img src="assets/rpl/formed.webp" alt="Formed network" />
<small>
Figure 4: the network is formed.
</small></p>
<h2 id="maintenance-of-a-rpl-network"><a class="header" href="#maintenance-of-a-rpl-network">Maintenance of a RPL network</a></h2>
<p>The <em>DIO</em> messages will be sent by nodes even after the DODAG is formed. The goal of sending <em>DIO</em> messages for the whole 
life of a RPL network is to maintain or upgrade the formed DODAG. However, the constant generation of control messages 
can consume a lot of energy. To preserve resources, the sending of control messages is minimized and only done when necessary,
through the use of the <strong>Trickle Timer algorithm</strong>.</p>
<p>The <strong>Trickle Timer algorithm</strong> monitors the consistency of packet exchange in the network. If the pattern is consistent 
and free of redundant or outdated data, the Trickle Timer decreases the rate of sending <em>DIO</em> messages exponentially.
However, if there are any inconsistencies in the network, the next <em>DIO</em> message is rescheduled and sent at the shortest 
possible time interval. In other words, this algorithm ensures that <em>DIOs</em> are aggressively advertised when the 
network is unstable and advertised at a slower pace when it is stable.</p>
<p>There are four parameters that control the functioning of the Trickle Timer:</p>
<ul>
<li>
<p>\(I_{min}\), which represents the minimum time interval between two <em>DIO</em> messages</p>
</li>
<li>
<p>\(I_{max}\), which represents the maximum time interval between two <em>DIO</em> message</p>
</li>
<li>
<p>\(k\), which represents the redundancy constant (the number of redundant control messages)</p>
</li>
<li>
<p>\(I\), which represents the size of the current time-interval</p>
</li>
</ul>
<p>In the beginning, \(I\) is set to a random value between \(I_{min}\) and \(2 \cdot I_{min}\).
<em>DIO</em> messages are sent when \(I\) expires and if the
counter (\(c\)) that keeps track of the consistent received messages is smaller than \(k\). 
If the network is stable, \(I\) is doubled until it reaches \(I_{max}\).
However, if inconsistencies are detected in the network, 
\(I\) is reset to a value between \(I_{min}\) and \(2 \cdot I_{min}\).
This ensures efficient use of resources while still being able to ensure the maintainance of the network.</p>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<ul>
<li>Network is formed by sending <em>DIO</em> messages</li>
<li><em>DIO</em> messages are sent periodically using the Trickle Timer algorithm</li>
<li><em>DIO</em> messages are sent to the <em>all-RPL-node</em> IPv6 multicast address (<code>ff02::a1</code>)</li>
<li>Nodes that receive a <em>DIO</em> message will join the RPL network</li>
<li>Nodes that do not receive a <em>DIO</em> message can send a <em>DIS</em> message</li>
<li>Packets only travel in an upward direction</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mop1-non-storing-mode"><a class="header" href="#mop1-non-storing-mode">MOP1: non-storing mode</a></h1>
<p>In this mode of operation, the network is configured such that both upward and downward routes are established.
This means that the root can send data packets to the nodes in the network 
and that any node in the network can transmit messages to any other node.</p>
<pre><code class="language-admonish note">In this mode of operation, IPv6 routing headers are used.
</code></pre>
<h2 id="rpl-network-formation-1"><a class="header" href="#rpl-network-formation-1">RPL network formation</a></h2>
<p>The formation of the network is done in the same way as in <strong>MOP 0</strong>.
However, in <strong>MOP 1</strong> the <em>DAO</em> messages are sent to the root when joining the network.
The root will answer with a <em>DAO-ACK</em> message, if requested by the <em>DAO</em> message.</p>
<p>A <em>DAO</em> message contains information about the parent of the node.
The address of the preferred parent is transmitted in the <strong>Transit Information RPL option</strong> of the <em>DAO</em> message.
The address of the child is transmitted in the <strong>Target RPL option</strong> of the <em>DAO</em> message.</p>
<p>When the root receives a <em>DAO</em> message, it will add the address of the child to its routing table together with the address of the parent.
When the network is formed, the root has a complete overview of the network topology.</p>
<p><img src="assets/rpl/daos.webp" alt="Sending DAO" />
<small>
Figure 1: node 1 and 4 send a <em>DAO</em> message to the root after joining the network.
</small></p>
<p>Nodes can now send data packets to any other node in the network.
First, the packet is sent to the parent of the node until it reaches the root.
The root will then add a <strong>source routing header (SRH)</strong> to the packet.
The SRH contains the path that the packet needs to follow toward the destination.
It is constructed by the root based on the routing table.</p>
<pre><code class="language-admonish example">Node 2 transmits a packet to node 3 (imagine that node 3 is not in range of node 2).
1. The packet is first transmitted to the preferred parent of node 2 (node 1).
2. Since node 1 is not the root, it will forward the packet to its preferred parent (the root).
3. The root will add a source routing header to the packet and send it to node 1.
4. Node 1 uses the source routing header to transmit the packet to node 3.

![Traveling packet](assets/rpl/formed-mop1.webp)
</code></pre>
<h2 id="maintainance-of-the-network"><a class="header" href="#maintainance-of-the-network">Maintainance of the network</a></h2>
<p>Just like in <strong>MOP 0</strong>, the network is maintained by sending <em>DIO</em> messages based on the <strong>Trickle timer</strong>.
However, routes also need to be maintained.
This is done by sending <em>DAO</em> messages to the root.
The root increments the DTSN in its <em>DIO</em> messages.
When a node receives a <em>DIO</em> message with a higher DTSN, it will send a <em>DAO</em> message to the root.
In smoltcp, nodes periodically send <em>DAO</em> messages to the root, without waiting for a <em>DIO</em> message with a higher DTSN.</p>
<h1 id="summary-1"><a class="header" href="#summary-1">Summary</a></h1>
<ul>
<li>Network is formed by sending <em>DIO</em> messages</li>
<li>When a node joins the network, it sends a <em>DAO</em> message to the root</li>
<li>The root answers with a <em>DAO-ACK</em> message (if requested)</li>
<li>The root has a complete overview of the network topology</li>
<li>Nodes can send data packets to any other node in the network</li>
<li>The root adds a <strong>source routing header (SRH)</strong> to downward packets</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mop2-storing-mode-without-multicast"><a class="header" href="#mop2-storing-mode-without-multicast">MOP2: storing mode without multicast</a></h1>
<p>In this mode of operation, the network is formed like non-storing mode, but the <em>DAO</em> messages are sent to the preferred parent.
Each node stores a routing table containing information on how to reach all their descendants (all the nodes in their subtree).
A node receiving a <em>DAO</em> transmits a new <em>DAO</em> message to its own preffered parent.
The route information is propagated upwards until it reaches the root.</p>
<p>Since the <em>DAO</em> messages are sent in one hop, the transit information option,
usually used to indicate the parent of the node, is left empty.
Instead, the destination address of the <em>DAO</em> message is used as the address of the preferred parent.</p>
<p><img src="assets/rpl/daos-mop2.webp" alt="Sending DAO with transit information empty" />
<small>
Figure 1: node 1 and 4 send a <em>DAO</em> message to the root after joining the network.
The transit information option is left empty.
</small></p>
<p>Nodes can now send data packets to any other node in the network, since they have a downward route to all their descendants.
When a node receives a packet, it first checks if it has a downward route to the destination of the packet.
A packet first goes to a common ancestor of the sender and receiver, and then it is forwarded downwards to the receiver.</p>
<pre><code class="language-admonish example">Node 2 transmits a packet to node 3 (imagine that node 3 is not in range of node 2).
1. The packet is first transmitted to the preferred parent of node 2 (node 1),
   since node 2 does not have a downward route to node 3.
2. Node 1 forwards the packet to node 3, since it has a downward route to node 3.

![Traveling packet](assets/rpl/formed-mop2.webp)
</code></pre>
<h1 id="summary-2"><a class="header" href="#summary-2">Summary</a></h1>
<ul>
<li>Every node in the network has an overview of the network topology.</li>
<li>Packets travel via a common ancestor of the sender and receiver.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mop3-storing-mode-with-multicast"><a class="header" href="#mop3-storing-mode-with-multicast">MOP3: storing mode with multicast</a></h1>
<pre><code class="language-admonish warning">This is a work in progress!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-message-formats"><a class="header" href="#control-message-formats">Control Message Formats</a></h1>
<script> document.createElement("warn"); </script>
<script> document.createElement("success"); </script>
<style>
:root {
    --red:   rgb(198, 0, 26);
    --green: rgb(0, 118, 85);
}

warn {
    color: var(--red);
    font-weight: bold;
}

success {
    color: var(--green);
    font-weight: bold;
}
</style>
<h2 id="dodag-information-solicitation-dis"><a class="header" href="#dodag-information-solicitation-dis">DODAG Information Solicitation (DIS)</a></h2>
<p>Sent by nodes that are not part of a RPL network to request information
about existing DODAGs in range of the node.
It is broadcasted, however, it can be unicast if it is for probing.
Using the <a href="rpl-msg-formats.html#solicited-information">Solicited Information</a> option, the DODAGs are filtered,
i.e., filtering on Version number, RPL Instance ID and/or DODAG ID.</p>
<h4 id="packet-structure"><a class="header" href="#packet-structure">Packet structure</a></h4>
<pre><code class="language-txt"> 0                   1                   2
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Flags     |   Reserved    |   Option(s)...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<ul>
<li><strong>Flags</strong>: unused field, must be set to zero.</li>
<li><strong>Reserved</strong>: unused field, must be set to zero.</li>
<li><strong>Option(s)</strong>: <a href="rpl-msg-formats.html#pad1">Pad1</a>, <a href="rpl-msg-formats.html#padn">PadN</a>, <a href="rpl-msg-formats.html#solicited-information">Solicited Information</a>.</li>
</ul>
<p><strong>Scope</strong>: all-RPL-nodes multicast address, or link-local unicast address</p>
<h4 id="sending-a-dis"><a class="header" href="#sending-a-dis">Sending a DIS</a></h4>
<ol>
<li>The node <strong>is</strong> a ROOT node:
<ul>
<li>A ROOT node should never send a DIS, unless it is [probing].
When probing, the DIS message is a unicast message.</li>
</ul>
</li>
<li>The node <strong>is</strong> a LEAF node:
<ul>
<li>Never sends a DIS.</li>
</ul>
</li>
<li>The node <strong>is not</strong> a LEAF node:
<ul>
<li>The node <strong>is not</strong> part of a DODAG:
<ul>
<li>Transmit a multicast DIS message.
Usually this is only sent after 5 seconds and then every 60 seconds.
The DIS message MAY contain a <a href="rpl-msg-formats.html#solicited-information">Solicited Information</a> option,
which is used for filtering DODAGs.</li>
</ul>
</li>
<li>The node <strong>is</strong> part of a DODAG:
<ul>
<li>The node should not send a DIS, unless it is [probing].
When probing, the DIS message is a unicast message.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="receiving-a-dis"><a class="header" href="#receiving-a-dis">Receiving a DIS</a></h4>
<ol>
<li>The node <strong>is</strong> a ROOT node:
<ul>
<li>Check if the <a href="rpl-msg-formats.html#solicited-information">Solicited Information</a> option is present.
This option has predicates that we need to match on.</li>
<li>After matching the predicates:
<ul>
<li><strong>Multicast</strong> DIS: reset the [Trickle] timer.
When the timer expires, a <warn>multicast</warn> <a href="rpl-msg-formats.html#dodag-information-object-dio">DIO</a> message is transmitted.</li>
<li><strong>Unicast</strong> DIS: <strong>do not</strong> reset the [Trickle] timer, but respond with a <warn>unicast</warn> <a href="rpl-msg-formats.html#dodag-information-object-dio">DIO</a> message,
which MUST contain a <a href="rpl-msg-formats.html#dodag-configuration">DODAG Configuration</a> option.</li>
</ul>
</li>
</ul>
</li>
<li>The node <strong>is</strong> a LEAF node:
<ul>
<li>Ignore the DIS message.</li>
</ul>
</li>
<li>The node <strong>is not</strong> a LEAF node:
<ul>
<li>The node <strong>is</strong> part of a DODAG: handle the message like the ROOT node.</li>
<li>The node <strong>is not</strong> part of a DODAG: <warn>ignore</warn> the message.</li>
</ul>
</li>
</ol>
<hr />
<h2 id="dodag-information-object-dio"><a class="header" href="#dodag-information-object-dio">DODAG Information Object (DIO)</a></h2>
<p>Sent by nodes that are part of a RPL network.
It is broadcasted, however, it can be unicast if it is for probing.
They send this message periodicaly, based on the Trickle timer.
They are also sent as a response on a <a href="rpl-msg-formats.html#dodag-information-solicitation-dis">DIS</a> message.
The message contains information about the DODAG it is part of.
More information is usually contained in a <a href="rpl-msg-formats.html#dodag-configuration">DODAG Configuration</a> option.</p>
<h4 id="packet-structure-1"><a class="header" href="#packet-structure-1">Packet structure</a></h4>
<pre><code class="language-txt"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| RPLInstanceID |Version Number |             Rank              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|G|0| MOP | Prf |     DTSN      |     Flags     |   Reserved    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                            DODAGID                            +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Option(s)...
+-+-+-+-+-+-+-+-+
</code></pre>
<ul>
<li><strong>RplInstanceId</strong>: the RPL instance ID.</li>
<li><strong>Version Number</strong> the version of the RPL isntance, specifies an iteration (<a href="">Section 8.2</a>).</li>
<li><strong>Rank</strong>: shows a relative distance from the advertising node to the root (<a href="">Section 8.2</a>).</li>
<li><strong>G (Grounded)</strong>: indicates if the scope of the application is met or not (application specific and in our case always 0).</li>
<li><strong>0</strong>: unused field, must be set to zero.</li>
<li><strong>MOP (Mode Of Operation)</strong>: the mode of operation of the DODAG.</li>
<li><strong>Prf (Preference)</strong>: indicates how preferable the root node is (0 is least preferred) (<a href="">Section 8.2</a>).</li>
<li><strong>DTSN (DAO Trigger Sequence Number)</strong>: used to maintain downward routes (<a href="">Section 9</a>).</li>
<li><strong>Flags</strong>: unused field, must be set to zero.</li>
<li><strong>Reserved</strong>: unused field, must be set to zero.</li>
<li><strong>DODAGID</strong>: the identifier of the root, which is the IPv6 address of the root.</li>
<li><strong>Options(s)</strong>: <a href="rpl-msg-formats.html#pad1">Pad1</a>, <a href="rpl-msg-formats.html#padn">PadN</a>, <a href="rpl-msg-formats.html#dag-metric-container">DAG Metric Container</a>, <a href="rpl-msg-formats.html#route-information">Route Information</a>, <a href="rpl-msg-formats.html#dodag-configuration">DODAG Configuration</a>, <a href="rpl-msg-formats.html#prefix-information">Prefix Information</a>.</li>
</ul>
<p><strong>Scope</strong>: all-RPL-nodes multicast address, or link-local unicast address</p>
<h4 id="sending-a-dio"><a class="header" href="#sending-a-dio">Sending a DIO</a></h4>
<ol>
<li>
<p>The node is a ROOT node:</p>
<ul>
<li>
<p>Based on the Trickle timer a <warn>multicast</warn> DIO message is transmitted,
containing a <a href="rpl-msg-formats.html#dodag-configuration">DODAG Configuration</a> option.
Note that the standard does not require this.
However, the option contains useful information about the Trickle timer and the
objective function.</p>
<p>If nodes in range, not connected to a DODAG, are interested in this option
(they require to know the objective function that is used),
then they will send a <warn>unicast</warn> <a href="rpl-msg-formats.html#dodag-information-solicitation-dis">DIS</a> message.
As a response, a <warn>unicast</warn> DIO message is sent, which MUST contain a 
<a href="rpl-msg-formats.html#dodag-configuration">DODAG Configuration</a> option.
If the number of interested nodes is high, then the overhead of the exchange of 
<warn>unicast</warn> messages might be significant.</p>
<p>The following values are set by the user of the library:</p>
<ul>
<li>RPL Instance ID</li>
<li>Version number</li>
<li>Grounded (G)</li>
<li>Mode of Operation (MOP)</li>
<li>Preference (Prf)</li>
<li>DODAG ID</li>
</ul>
<p>The Rank is equal to the ROOT Rank value.
The DTSN is a sequence counter starting with the default value, 
[incremented] when new route information is required. </p>
</li>
</ul>
</li>
<li>
<p>The node <strong>is</strong> a LEAF node:</p>
<ul>
<li>A LEAF node does not transmit a DIO [Section 8.5].</li>
</ul>
</li>
<li>
<p>The node <strong>is not</strong> a LEAF node:</p>
<ul>
<li>
<p>The node <strong>is</strong> part of a DODAG: 
behave as the ROOT node, however, the DIO information was obtained when receiving a DIO message
from a node with a lower Rank.
The Rank was computed when selecting a parent.
The DTSN is a sequence counter starting with the default value,
[incremented] when new route information is required. </p>
</li>
<li>
<p>The node <strong>is not</strong> part of a DODAG: the node does not send a DIO.</p>
</li>
</ul>
</li>
</ol>
<h4 id="receiving-a-dio"><a class="header" href="#receiving-a-dio">Receiving a DIO</a></h4>
<ol>
<li>
<p>The node is a ROOT node:</p>
<ul>
<li>The DIO is ignored<sup class="footnote-reference"><a href="#neighbours">1</a></sup>.</li>
</ul>
</li>
<li>
<p>The node <strong>is</strong> part of a DODAG:</p>
<ul>
<li>Ignore if the Rank is higher than ours.</li>
<li>Add sender to the parent list and check for new preferred parent.
<ul>
<li>Selected a new preferred parent:
<ul>
<li>MOP 1: Send DAO message to the ROOT node. The parent address is in the DAO <a href="rpl-msg-formats.html#transit-information">Transit Information</a> option.</li>
<li>MOP 2-3: 
<ul>
<li>Send No-path DAO message to old preferred parent.</li>
<li>Send DAO message to the new preferred parent (which is forwarded to the ROOT node).
The destination needs to be the preferred parent, since this contains the 
information about who the parent is.
There is no <a href="rpl-msg-formats.html#transit-information">Transit Information</a> option.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>The node <strong>is not</strong> part of a DODAG:</p>
<ul>
<li>The node <strong>is</strong> a leaf:
<ul>
<li>Accept the DIO and select sender as a parent.</li>
<li><success>The node is now part of a DODAG</success>.</li>
</ul>
</li>
<li>The node <strong>is not</strong> a leaf:
<ul>
<li>A <a href="rpl-msg-formats.html#dodag-configuration">DODAG Configuration</a> option <strong>is</strong> present:
<ul>
<li>The node accepts the DIO, iff the mode of operation and objective function is the same.
<warn>The mode of operation and objective function(s) are set by the developer</warn>.
The node then joins the network:
<ul>
<li>Copy the following fields (<warn>a non-root node cannot modify these</warn>):
<ul>
<li>Grounded (G)</li>
<li>Mode of Operation (MOP)</li>
<li>Preference (Prf)</li>
<li>Version number</li>
<li>RPL Instance ID</li>
<li>DODAG ID</li>
</ul>
</li>
<li>Select the sender of the DIO as a parent and send DAOs accordingly (see step 2).</li>
<li>Calculate a Rank using the Objective Function.</li>
<li>Reset the Trickle timer to make sure that this node now also sends DIOs.</li>
<li><success>The node is now part of a DODAG</success>.</li>
</ul>
</li>
</ul>
</li>
<li>A <a href="rpl-msg-formats.html#dodag-configuration">DODAG Configuration</a> option <strong>is not</strong> present:
<ul>
<li>Transmit a <warn>unicast</warn> <a href="rpl-msg-formats.html#dodag-information-soliciation-dis">DIS</a> message to gain information about the used objective function.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p><sup class="footnote-reference"><a href="#neighbours">1</a></sup> Note that in smoltcp, we check the DIO, even as a ROOT node.
If the DIO is part of the ROOTs DODAG, then we add the node to the neighbour list.
Otherwise we don't have the link-layer address of our neighbours.</p>
</blockquote>
<hr />
<h2 id="destination-advertisement-object-dao"><a class="header" href="#destination-advertisement-object-dao">Destination Advertisement Object (DAO)</a></h2>
<p>Sent by nodes that have selected a parent.
For Mode of Operation 1 (non-storing), the message is sent to the DODAG root.
For Mode of Operation 2 and 3, the message is sent to the preferred parent.
It is sent to propagate routing information.</p>
<h4 id="packet-structure-2"><a class="header" href="#packet-structure-2">Packet structure</a></h4>
<pre><code class="language-txt"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| RPLInstanceID |K|D|   Flags   |   Reserved    | DAOSequence   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                            DODAGID*                           +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Option(s)...
+-+-+-+-+-+-+-+-+
</code></pre>
<ul>
<li><strong>RplInstanceId</strong>: the RPL instance ID.</li>
<li><strong>K</strong>: if set, an acknowledgement is requested.</li>
<li><strong>D</strong>: if set, the DODAGID is present in the message.</li>
<li><strong>Flags</strong>: unused field, must be set to zero.</li>
<li><strong>Reserved</strong>: unused field, must be set to zero.</li>
<li><strong>DAOSequence</strong>: indicates the freshness of the information.
It is incremented for each unique DAO message, echoed in the DAO-ACK.</li>
<li><strong>DODAGID</strong>: the identifier of the root, which is the IPv6 address of the root.</li>
<li><strong>Options</strong>: <a href="rpl-msg-formats.html#pad1">Pad1</a>, <a href="rpl-msg-formats.html#padn">PadN</a>, <a href="rpl-msg-formats.html#rpl-target">RPL Target</a>, <a href="rpl-msg-formats.html#transit-information">Transit Information</a>, <a href="rpl-msg-formats.html#rpl-target-descriptor">RPL Target Descriptor</a>.</li>
</ul>
<p><strong>Scope</strong>: in <strong>MOP 1</strong>, global or unique-local addresses are used for the source and
destination address.
In other modes, the addresses are link-local addresses.</p>
<h4 id="sending-a-dao"><a class="header" href="#sending-a-dao">Sending a DAO</a></h4>
<ol>
<li>
<p>The node is a ROOT node:</p>
<ul>
<li>The ROOT node should <strong>not</strong> send a DAO.</li>
</ul>
</li>
<li>
<p>The node <strong>is</strong> part of a DODAG:</p>
<ul>
<li>
<p>First parent selection:</p>
<ul>
<li>
<p><strong>MOP 1</strong>: send a DAO to the <warn>DODAG root</warn>,
containing a <a href="rpl-msg-formats.html#transit-information">Transit Information</a> option and a <a href="rpl-msg-formats.html#rpl-target">RPL Target</a> option.
The Transit Information option copntians the parent and the route lifetime.
The RPL Target option contains the original sender IPv6 prefix <strong>?</strong> address of the DAO message.</p>
</li>
<li>
<p><strong>MOP 2 - 3</strong>: send a DAO to the <warn>preferred</warn> parent,
containing a <a href="rpl-msg-formats.html#transit-information">Transit Information</a> option and a <a href="rpl-msg-formats.html#rpl-target">RPL Target</a> option.
The Transit Information option only contains the route lifetime and not the parent address.
The parent address is already in the IPv6 destination address.
The RPL Target option contains the original sender IPv6 prefix <strong>?</strong> address of the DAO message.</p>
</li>
</ul>
</li>
<li>
<p>Switched parent:</p>
<ul>
<li>
<p><strong>MOP 1</strong>: send a DAO to the <warn>DODAG root</warn>,
containing a <a href="rpl-msg-formats.html#transit-information">Transit Information</a> option and a <a href="rpl-msg-formats.html#rpl-target">RPL Target</a> option.
The Transit Information option copntians the parent and the route lifetime.
The RPL Target option contains the original sender IPv6 prefix <strong>?</strong> address of the DAO message.</p>
</li>
<li>
<p><strong>MOP 2 - 3</strong>: </p>
<ul>
<li>Send a No-Path DAO to the old parent,
containing a <a href="rpl-msg-formats.html#transit-information">Transit Information</a> option and a <a href="rpl-msg-formats.html#rpl-target">RPL Target</a> option.
The Transit Information option has a <warn>path lifetime of 0x00</warn>.</li>
<li>Send a DAO to the <warn>preferred</warn> parent,
containing a <a href="rpl-msg-formats.html#transit-information">Transit Information</a> option and a <a href="rpl-msg-formats.html#rpl-target">RPL Target</a> option.
The Transit Information option only contains the route lifetime and not the parent address.
The parent address is already in the IPv6 destination address.
The RPL Target option contains the original sender IPv6 prefix <strong>?</strong> address of the DAO message.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Maintanance of the route:</p>
<ul>
<li>
<p><strong>MOP 1</strong>: the ROOT node increments the DTSN in the DIO messages.
When a node receives a DIO from the its parent with a new DTSN,
it should transmit a DAO to the ROOT, as previously explained.
<warn>In smoltcp, the ROOT never increments the DTSN, and each node just keeps track of a DAO expiration timer,
just like <strong>MOP 2 - 3</strong></warn>.</p>
</li>
<li>
<p><strong>MOP 2 - 3</strong>: each non-leaf and non-ROOT node should keep track of a DAO expiration timer.
When this timer expires, the node needs to transmit a DAO to its preferred parent,
as previously explained.
The DAO retransmition should be one or two minutes before the expriation of the route.</p>
</li>
</ul>
</li>
</ul>
<p>Every time a DAO message is transmitted, the DAO Sequence number is incremented.
<warn>smoltcp always enables the acknowledgement request flag. The lifetime of the route is 30 minutes. Missing 
a DAO is significant</warn>.</p>
</li>
<li>
<p>The node <strong>is not</strong> part of a DODADG:</p>
<ul>
<li>The node should <strong>not</strong> send a DAO since it has not selected a parent.</li>
</ul>
</li>
</ol>
<h4 id="receiving-a-dao"><a class="header" href="#receiving-a-dao">Receiving a DAO</a></h4>
<ol>
<li>
<p>The node is a ROOT node:</p>
<ul>
<li>Store the route in the routing table.</li>
</ul>
</li>
<li>
<p>The node <strong>is</strong> a LEAF node:</p>
<ul>
<li>Should never receive a DAO, so ignore the message.</li>
</ul>
</li>
<li>
<p>The node <strong>is not</strong> a LEAF node:</p>
<ul>
<li>
<p><strong>MOP 1</strong>: all DAO messages are forwared to the default route,
untill it reaches the destination (which should be the ROOT).</p>
</li>
<li>
<p><strong>MOP 2</strong>:</p>
<ul>
<li>Store the information in the routing table.</li>
<li>If the information is new, create a new DAO message which is sent to the preferred parent.
Information is new when:
<ul>
<li>It has a newer Path Sequence number.</li>
<li>It has additional Path Control bits.</li>
<li>It is a No-Path DAO message.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Node is the destination address and ACK is requested:</p>
<ul>
<li>Transmit a DAO-ACK to the source of the DAO, with the correct status flags.</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr />
<h2 id="dao-acknowledgement-dao-ack"><a class="header" href="#dao-acknowledgement-dao-ack">DAO Acknowledgement (DAO-ACK)</a></h2>
<p>The DAO-ACK is a response on a DAO that requested an acknowledgement.
They are unicast messages.</p>
<h4 id="packet-structure-3"><a class="header" href="#packet-structure-3">Packet structure</a></h4>
<pre><code class="language-txt"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| RPLInstanceID |D|  Reserved   |  DAOSequence  |    Status     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                            DODAGID*                           +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Option(s)...
+-+-+-+-+-+-+-+-+
</code></pre>
<ul>
<li><strong>RplInstanceId</strong>: the RPL instance ID.</li>
<li><strong>D</strong>: if set, the DODAGID is present in the message.</li>
<li><strong>Reserved</strong>: unused field, must be set to zero.</li>
<li><strong>DAOSequence</strong>: correlates to the DAO message.</li>
<li><strong>Status</strong>: indicates the completion.
<ul>
<li>Value of 0: the parent accepts to be the parent.</li>
<li>Value of 1-127: the parent suggests to find another parent.</li>
<li>Value of 127-255: the parent rejects to be the parent.</li>
</ul>
</li>
<li><strong>DODAGID</strong>: the identifier of the root, which is the IPv6 address of the root.</li>
<li><strong>Options</strong>: <a href="rpl-msg-formats.html#pad1">Pad1</a>, <a href="rpl-msg-formats.html#padn">PadN</a>.</li>
</ul>
<p><strong>Scope</strong>: in <strong>MOP 1</strong>, global or unique-local addresses are used for the source and
destination address.
In other modes, the addresses are link-local addresses.</p>
<h4 id="sending-a-dao-ack"><a class="header" href="#sending-a-dao-ack">Sending a DAO-ACK</a></h4>
<p>When the <code>K</code> flag is set to 1 in the <a href="rpl-msg-formats.html#destination-advertisement-object-dao">DAO</a> message, respond with a DAO-ACK with the correct
status.</p>
<h4 id="receiving-a-dao-ack"><a class="header" href="#receiving-a-dao-ack">Receiving a DAO-ACK</a></h4>
<ol>
<li>
<p>The node is the destination: mark the DAO as acknowledged.</p>
<ul>
<li>Status 0: the parent is selected.</li>
<li>Status 1 - 127: remove the parent from the parent set if the parent set has more than 1 parent entry.
This is not a hard requirement.</li>
<li>Status 127 - 255: remove the parent from the parent set.</li>
</ul>
</li>
<li>
<p>The node is not the destination: forward the message if the node is not a LEAF node.</p>
</li>
</ol>
<hr />
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<h3 id="pad1"><a class="header" href="#pad1">Pad1</a></h3>
<p>Used for option alignement.</p>
<pre><code class="language-txt"> 0
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|   Type = 0x00 |
+-+-+-+-+-+-+-+-+
</code></pre>
<h3 id="padn"><a class="header" href="#padn">PadN</a></h3>
<p>Used for option alignement.</p>
<pre><code class="language-txt"> 0                   1                   2
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
|   Type = 0x01 | Option Length | 0x00 Padding...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -

</code></pre>
<h3 id="dag-metric-container"><a class="header" href="#dag-metric-container">DAG Metric Container</a></h3>
<p>Contains metrics about the network.
There can be more than one DAG Metric Container option.
More information about metrics are in <a href="https://datatracker.ietf.org/doc/html/rfc6551">RFC6551: Routing Metrics Used for Path Calculation in Low-Power and Lossy Networks</a></p>
<pre><code class="language-txt"> 0                   1                   2
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
|   Type = 0x02 | Option Length | Metric Data
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -
</code></pre>
<h3 id="route-information"><a class="header" href="#route-information">Route Information</a></h3>
<p><warn>smoltcp does not yet use Route Information Options</warn>.
More information can be found in <a href="https://datatracker.ietf.org/doc/html/rfc6550#section-6.7.5">Section 6.7.5</a>.</p>
<pre><code class="language-txt"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 0x03 | Option Length | Prefix Length |Resvd|Prf|Resvd|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Route Lifetime                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
.                   Prefix (Variable Length)                    .
.                                                               .
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<h3 id="dodag-configuration"><a class="header" href="#dodag-configuration">DODAG Configuration</a></h3>
<p>This option contains information about the DODAG.
This information usually does not change within a DODAG and it is not
necassary to include it in each [DIO].
The ROOT is the only node that sets this information.</p>
<pre><code class="language-txt"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 0x04 |Opt Length = 14| Flags |A| PCS | DIOIntDoubl.  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  DIOIntMin.   |   DIORedun.   |        MaxRankIncrease        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      MinHopRankIncrease       |              OCP              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Reserved    | Def. Lifetime |      Lifetime Unit            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</code></pre>
<ul>
<li><strong>Flags</strong>: unused, set to zero, ignored.</li>
<li><strong>A</strong>: 0 if there is no security.</li>
<li><strong>PCS (Path Control Size)</strong>: number of bits to be allocated to the path control field.</li>
<li><strong>DIOIntDoubl.</strong>: variable used by the Trickle timer.</li>
<li><strong>DIOIntMin.</strong>: variable used by the Trickle timer.</li>
<li><strong>DIORedun.</strong>: variable used by the Trikle timer.</li>
<li><strong>MaxRankIncrease</strong>: variable used by the objective function.</li>
<li><strong>MinHopRankIncrease</strong>: variable used by the objective function.</li>
<li><strong>OCP (Objective Code Point)</strong>: identifies what objective function is used by the DODAG.</li>
<li><strong>Reserved</strong>: unused, set to zero, ignored.</li>
<li><strong>Def. Lifetime</strong>: lifetime that is used as default for all RPL routes in the routing tables.</li>
<li><strong>Lifetime Unit</strong>: lifetime unit in seconds that is used for all RPL routes in the routing tables.</li>
</ul>
<h3 id="rpl-target"><a class="header" href="#rpl-target">RPL Target</a></h3>
<p>This option contains information about the child.
The message is only used in combination wiath a Transit Information option.
The target prefix field contains the global or unique-local IPv6 address.</p>
<pre><code class="language-txt"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 0x05 | Option Length |     Flags     | Prefix Length |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                Target Prefix (Variable Length)                |
.                                                               .
.                                                               .
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</code></pre>
<ul>
<li><strong>Flags</strong>: unused, set to zero, ignored.</li>
<li><strong>Prefix Length</strong>: number of valid leading bits of the prefix.</li>
<li><strong>Target Prefix</strong>: contains the prefix or the full IPv6 address of the child node.</li>
</ul>
<h3 id="transit-information"><a class="header" href="#transit-information">Transit Information</a></h3>
<p>This option contains information about the lifetime of a route, the parent used in the route
or to invalidate a route.</p>
<pre><code class="language-txt">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 0x06 | Option Length |E|    Flags    | Path Control  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Path Sequence | Path Lifetime |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                                                               |
+                                                               +
|                                                               |
+                        Parent Address*                        +
|                                                               |
+                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<ul>
<li><strong>E (External)</strong>: indicates that the parent router redistributes external targets into the RPL network.
An External Target is a Target that has been learned through an alternate protocol.</li>
<li><strong>Flags</strong>: unused, set to zero, ignored.</li>
<li><strong>Path Control</strong>: limits the number of DAO parents to which a DAO message advertises connectivity and communicate
preference among the parents.</li>
<li><strong>Path Sequence</strong>: increased whenever information in this option is newer information.</li>
<li><strong>Path Lifetime</strong>: the length of time in Lifetime Units that the prefix is valid for route determination.</li>
<li><strong>Parent Address</strong>: 
<ul>
<li><strong>MOP 1</strong>: the address of the parent.</li>
<li><strong>MOP 2 - 3</strong>: field is not present.</li>
</ul>
</li>
</ul>
<h3 id="solicited-information"><a class="header" href="#solicited-information">Solicited Information</a></h3>
<p>This option is used when sending a DIS to filter potential DODAGs.
When receiving such an option, a node will check if it matches the predicates.</p>
<pre><code class="language-txt">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 0x07 |Opt Length = 19| RPLInstanceID |V|I|D|  Flags  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                            DODAGID                            +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version Number |
+-+-+-+-+-+-+-+-+
</code></pre>
<ul>
<li><strong>RPLInstanceID</strong>: The RPL Instance ID predicate.</li>
<li><strong>V</strong>: Filter using the Version number.</li>
<li><strong>I</strong>: Filter using the RPL Instance ID.</li>
<li><strong>D</strong>: Filter using the DODAG ID.</li>
<li><strong>Flags</strong>: unused, set to zero, ignored.</li>
<li><strong>DODAGID</strong>: The DODAG ID predicate.</li>
<li><strong>Version Number</strong>: The Version Number predicate.</li>
</ul>
<h3 id="prefix-information"><a class="header" href="#prefix-information">Prefix Information</a></h3>
<p>This option is used by a router to indicate nodes in the DODAG what 
prefix to use.</p>
<pre><code class="language-txt"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 0x08 |Opt Length = 30| Prefix Length |L|A|R|Reserved1|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Valid Lifetime                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Preferred Lifetime                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Reserved2                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                            Prefix                             +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<ul>
<li><strong>Prefix Length</strong>: the number of leading bits in the Prefix field that are valid.</li>
<li><strong>L</strong>: indicates that this prefix can be used for on-link determination.</li>
<li><strong>A</strong>: indicates that this prefix can be used for stateless address configuration.</li>
<li><strong>R</strong>: indicaties that the prefix field contains a complete IPv6 address assigned to the sending router.</li>
<li><strong>Reserved1</strong>: unused, set to zero, ignored.</li>
<li><strong>Valid Lifetime</strong>: time in seconds that the prefix is valid for the purpose of on-link determination.</li>
<li><strong>Preferred Lifetime</strong>: time in seconds that the addresses generated with the prefix with SLAAC are valid.
This should not be higher than the valid lifetime.</li>
<li><strong>Reserved2</strong>: unused, set to zero, ignored.</li>
<li><strong>Prefix</strong>: an IPv6 address or a prefix of an IPv6 address.</li>
</ul>
<h3 id="rpl-target-descriptor"><a class="header" href="#rpl-target-descriptor">RPL Target Descriptor</a></h3>
<p>This option is used to tag a target.
When used, it is always associated with a RPL Target option.
It must be copied by other nodes in the network and not modified.
<warn>smoltcp does not use this option</warn>.</p>
<pre><code class="language-txt"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 0x09 |Opt Length = 4 |           Descriptor
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       Descriptor (cont.)       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</code></pre>
<hr />
<h2 id="ipv6-hop-by-hop-rpl-option"><a class="header" href="#ipv6-hop-by-hop-rpl-option">IPv6 Hop-by-Hop RPL option</a></h2>
<hr />
<h2 id="ipv6-source-routing-header"><a class="header" href="#ipv6-source-routing-header">IPv6 Source routing header</a></h2>
<hr />
<h2 id="incrementing-the-dtsn"><a class="header" href="#incrementing-the-dtsn">Incrementing the DTSN</a></h2>
<p><strong>MOP 1</strong>: If the DIO from the parent of a node has increased DTSN, then the node itself has to increment its DTSN.</p>
<p><strong>MOP 2 - 3</strong>: If the DIO from the parent of a node has increased DTSN, it is not</p>
<h2 id="incrementing-the-path-sequence-number"><a class="header" href="#incrementing-the-path-sequence-number">Incrementing the Path Sequence Number</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimizations"><a class="header" href="#optimizations">Optimizations</a></h1>
<!--## DODAG Configuration in DIO-->
<!--DIO messages MAY contain a DODAG configuration option (16 bytes).-->
<!--In smoltcp, we only add this option when a multicast DIO message is sent when the Trickle timer is in the first interval.-->
<!--A Trickle timer is in the first interval at startup or when it is reset.-->
<!--When a node receives a DIO without the DODAG Configuration option as a response on a multicast DIS,-->
<!--the node will send a unicast DIS.-->
<!--Responding on a unicast DIS is always a unicast DIO containing a DODAG Configuration option.-->
<!--It is important for a node to receive a DODAG Configuration option when it has never joined a network.-->
<!--This option contains information related to the objective function and trickle timer.-->
<!--If the objective function is different, this node can only join as a leaf and not act as a router in the network.-->
<!--Note that Contiki-NG always sends DIO messages containing a DODAG Configuration option.-->
<!--However, we think that this is a (tiny) waste of power.-->
<!--This is something that we need to measure.-->
<h2 id="trickle-timer-implementation"><a class="header" href="#trickle-timer-implementation">Trickle timer implementation</a></h2>
<p>The Trickle timer that is implemented in smoltcp uses the <a href="https://d1wqtxts1xzle7.cloudfront.net/71402623/E-Trickle_Enhanced_Trickle_Algorithm_for20211005-2078-1ckh34a.pdf?1633439582=&amp;response-content-disposition=inline%3B+filename%3DE_Trickle_Enhanced_Trickle_Algorithm_for.pdf&amp;Expires=1690468547&amp;Signature=GWAtYVYOGyXrGmy~PHBDmcjxtgjGv93RuCCTxDcW1x3gWIlGw2DIxXMXluHJhO5vcR8HR~4qW5zMUmYw0fcrYvvoWrbBOAVxWs5MVF3gr8rTFsenuuSdG9Gi8OQFHnHjG8-p7~0RfHlGU5hxednaKu-dt5ECfzhsCfbfeTTCRk4Zm~CjDW4eAimwRpxuGZ9SWoySnnbOCurAtijdcdqw~YVuJV5M7VunKXgDPjEyEnCEAuwpLurPMvg7sAOpJeOaM7Yz7qCvGAe-oG9Cr8xE805TCxCcWRkOlKQHWFq6r1bK3htwgESB6iumT7Y28IbFvCYQZ7gpFviIH13jBeXFNA__&amp;Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA">enhanced Trickle</a> timer.</p>
<p>Note that Contiki-NG also implements this timer.</p>
<h2 id="rank-error"><a class="header" href="#rank-error">Rank-Error</a></h2>
<p>The standard sais that the rank-error bit must be set when a Rank error is detected.
A rank error occurs when a packet is traveling throught the DODAG in the wrong direction.
Such an error is not considered critical, but a second occurence is.
The standard provides an example in which case it might occur.
However, this looks like an edge case that will never occur.
Therefor, we immediatly drop a packet when a rank error is detected.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-the-project"><a class="header" href="#about-the-project">About the project</a></h1>
<p>The goal of this project is to add the RPL protocol to the <code>smoltcp</code> Rust library.
The project is funded by <a href="https://nlnet.nl/thema/NGIAssure.html">NLnet NGI Assure</a>.
More information about the project can be found on <a href="https://nlnet.nl/project/Smoltcp/">their website</a>.</p>
<hr />
<p><img src="assets/nlnet_banner.svg" alt="NLnet" width="50%"/></p>
<p><img src="assets/ngi_assure.svg" alt="NGI Assure" width="50%"/></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
