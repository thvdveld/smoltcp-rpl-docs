<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Using smoltcp RPL</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        <link href='https://fonts.googleapis.com/css?family=JetBrains Mono' rel='stylesheet'>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Using smoltcp</li><li class="chapter-item expanded "><a href="using_smoltcp.html"><strong aria-hidden="true">1.</strong> Setting up a basic stack</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Adding sockets</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Adding RPL</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Adding DNS</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Feature flags</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Protocols</li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 6LoWPAN</div></li><li class="chapter-item expanded "><a href="rpl_introduction.html"><strong aria-hidden="true">7.</strong> RPL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mop0.html"><strong aria-hidden="true">7.1.</strong> MOP0</a></li><li class="chapter-item expanded "><a href="mop1.html"><strong aria-hidden="true">7.2.</strong> MOP1</a></li><li class="chapter-item expanded "><a href="mop2.html"><strong aria-hidden="true">7.3.</strong> MOP2</a></li><li class="chapter-item expanded "><a href="mop3.html"><strong aria-hidden="true">7.4.</strong> MOP3</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="about.html">About</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Using smoltcp RPL</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This website provides comprehensive documentation on how to use <a href="https://github.com/smoltcp-rs/smoltcp">smoltcp</a> with the Routing Protocol for Low-power and Lossy Networks (RPL).</p>
<h1 id="smoltcp"><a class="header" href="#smoltcp">Smoltcp</a></h1>
<p><a href="https://github.com/smoltcp-rs/smoltcp">smoltcp</a> is a standalone, event-driven TCP/IP stack that is designed for bare-metal, real-time systems.
Its design goals are simplicity and robustness.
Its design anti-goals include complicated compile-time computations,
such as macro or type tricks, even at cost of performance degradation.
<strong>smoltcp</strong> is missing many widely deployed features,
usually because no one implemented them yet.</p>
<h1 id="rpl"><a class="header" href="#rpl">RPL</a></h1>
<p>The RPL protocol (<a href="https://datatracker.ietf.org/doc/html/rfc6550">RFC6550</a>)
is designed for networks that usually consist of low power devices and
where the network is generally susceptible to packet loss.
Read <a href="./rpl_introduction.html">here</a> if you want to know more about how the protocol works.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-smoltcp"><a class="header" href="#using-smoltcp">Using smoltcp</a></h1>
<blockquote>
<p>We're assuming that the final system configuration will use a stack with RPL routing protocol, 
using 6LoWPAN to convey IPv6 packets over an IEEE802.15.4 network.</p>
</blockquote>
<h2 id="1-adding-smoltcp-to-your-cargotoml"><a class="header" href="#1-adding-smoltcp-to-your-cargotoml">1. Adding <code>smoltcp</code> to your <code>Cargo.toml</code></a></h2>
<p>To be able to use <code>smoltcp</code> in your project, you must add it as a dependency in your <code>Cargo.toml</code> file.
However, <code>smoltcp</code> uses a lot of feature flags for configuration and therefore the correct ones need to be added.
For a IEEE802.15.4 device using 6LoWPAN and RPL, the following is added in the <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies.smoltcp]
version = &quot;0.9&quot;
default-features = false
features = [
	&quot;medium-ieee802154&quot;,
	&quot;proto-sixlowpan&quot;,
	&quot;proto-rpl&quot;
]
</code></pre>
<!--More information about the feature flags can be found [here](./feature_flags.md).-->
<h2 id="2-implementing-smoltcpphydevice-for-your-platform"><a class="header" href="#2-implementing-smoltcpphydevice-for-your-platform">2. Implementing <code>smoltcp::phy::Device</code> for your platform</a></h2>
<p><code>smoltcp</code> needs to be able to accept incoming packets and transmit packets.
For <code>smoltcp</code> to do this, a connection needs to be made between the TCP/IP stack and the hardware.
This is done by implementing the <a href="https://docs.rs/smoltcp/latest/smoltcp/phy/trait.Device.html"><code>smoltcp::phy::Device</code></a> trait for the hardware:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate smoltcp;
</span><span class="boring">use smoltcp::phy::DeviceCapabilities;
</span>pub trait RxToken {
    fn consume&lt;R, F&gt;(self, f: F) -&gt; R
    where
        F: FnOnce(&amp;mut [u8]) -&gt; R;
}

pub trait TxToken {
    fn consume&lt;R, F&gt;(self, len: usize, f: F) -&gt; R
    where
        F: FnOnce(&amp;mut [u8]) -&gt; R;
}

pub trait Device {
    type RxToken&lt;'a&gt;: RxToken
    where
        Self: 'a;
    type TxToken&lt;'a&gt;: TxToken
    where
        Self: 'a;

    fn receive(&amp;mut self, timestamp: Instant) -&gt; Option&lt;(Self::RxToken&lt;'_&gt;, Self::TxToken&lt;'_&gt;)&gt;;

    fn transmit(&amp;mut self, timestamp: Instant) -&gt; Option&lt;Self::TxToken&lt;'_&gt;&gt;;

    fn capabilities(&amp;self) -&gt; DeviceCapabilities;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="3-setting-up-the-smoltcp-stack"><a class="header" href="#3-setting-up-the-smoltcp-stack">3. Setting up the <code>smoltcp</code> stack</a></h2>
<p>Once you have the <code>Device</code> trait implemented, an <a href="https://docs.rs/smoltcp/latest/smoltcp/iface/struct.Interface.html"><code>Interface</code></a> can be created:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate smoltcp;
</span><span class="boring">use smoltcp::wire::Ieee802154Address;
</span><span class="boring">fn main() {
</span>let ll_addr = Ieee802154Address::Extended([0x1, 0x2, 0x3, 0x4, 0x5, 0x6 0x7, 0x8]);

// Create the device:
let mut device = MyDevice::new(ll_addr);

// Create the config for RPL:
let mut rpl_config = smoltcp::iface::RplConfig::new();

// Create the configuration for the stack:
let mut config = smoltcp::iface::Config::new();
config.hardware_addr =	Some(ll_addr.into());
config.pan_id = Some(Ieee802154Pan(0xbeef));

// Add the RPL config:
config.rpl = rpl_config;

// Create the sockets:
let mut sockets_buffer = [SocketStorage::EMPTY; 1];
let mut sockets = SocketSet::new(&amp;mut sockets_buffer[..]);

// Create the interface:
let mut iface = smoltcp::iface::Interface::new(config, device)?;

<span class="boring">}</span></code></pre></pre>
<h2 id="4-polling-the-smoltcp-stack"><a class="header" href="#4-polling-the-smoltcp-stack">4. Polling the <code>smoltcp</code> stack</a></h2>
<p>After the interface is created, the stack is ready to be polled (by calling the <a href="https://docs.rs/smoltcp/latest/smoltcp/iface/struct.Interface.html#method.poll"><code>poll</code></a> function on the interface).
Polling the stack transmits packets that were queued or handles received packets queued by the device.
If a packet is processed by the stack, the readiness of sockets might have changed.
Therefore, it is possible that the stack needs to be polled multiple times.
The <a href="https://docs.rs/smoltcp/latest/smoltcp/iface/struct.Interface.html#method.poll_delay"><code>poll_delay</code></a> function returns an <em>advisory wait</em> time for calling <code>poll</code> the next time. 
Calling <code>poll</code> before that time is only wasting energy, but is not harmful for the stack.
Calling <code>poll</code> after that duration might be harmful for the stack.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
	iface.poll(Instant::now(), device, sockets);

	match iface.poll_at(Instant::now()) {
		Some(Instant::ZERO) =&gt; continue,
		Some(d) =&gt; sleep(d),
		None =&gt; sleep_until_new_packet(),
	}
}
<span class="boring">}</span></code></pre></pre>
<h2 id="5-youre-all-set--for-now"><a class="header" href="#5-youre-all-set--for-now">5. You're all set ðŸŽ‰ (for now)</a></h2>
<p>That's it! There is nothing more that needs to be done, if you want a simple TCP/IP stack without sockets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="routing-protocol-for-low-power-and-lossy-networks"><a class="header" href="#routing-protocol-for-low-power-and-lossy-networks">Routing Protocol for Low-Power and Lossy Networks</a></h1>
<p>A Wireless Sensor Network (WSN) is a type of Low-Power and Lossy Network (LLN) 
that consists of small, constrained devices equipped with sensors and/or actuators. 
These devices are connected to the Internet and an end user through a central node 
known as the sink node. 
WSNs may include hundreds of these tiny, battery-powered devices that communicate 
with each other using short-range radio transmissions. 
In order to transmit data from one device to another, intermediate nodes act as relay nodes, 
forwarding the data along a multi-hop path towards the sink node. 
The use of low-power, lossy radio links, battery-powered nodes, 
and mesh topologies creates significant routing challenges for LLNs and WSNs.</p>
<p><img src="assets/rpl_intro/rpl_intro2.svg" alt="Empty RPL network" /></p>
<p>To address these challenges, the IETF Routing over Low-Power and Lossy Networks working group developed 
<a href="https://datatracker.ietf.org/doc/html/rfc6550"><strong>IPv6 Routing protocol for Low-power and Lossy Networks (RPL)</strong></a>. RPL supports <em>Point to Point (<strong>P2P</strong>)</em>, <em>Multipoint to Point (<strong>M2P</strong>)</em> and <em>Point to Multipoint (<strong>P2M</strong>)</em> traffic. 
<strong>P2P</strong> communication occurs between two nodes, <strong>M2P</strong> communication involves 
data being sent from multiple nodes to a central node, and <strong>P2M</strong> communication 
involves data being sent from a central node to multiple nodes. RPL uses <strong>upward</strong> 
and <strong>downward routes</strong> to facilitate these different types of traffic. Upward routes 
lead towards the root of the network, while downward routes start at the root and lead 
towards other nodes in the network.</p>
<h2 id="destination-oriented-directed-acyclic-graph-dodag"><a class="header" href="#destination-oriented-directed-acyclic-graph-dodag">Destination Oriented Directed Acyclic Graph (DODAG)</a></h2>
<p>RPL specifies how to construct a Directed Acyclic Graph (DAG) rooted at a single destination, 
known as a Destination-Oriented DAG (DODAG), using an objective function and a set of metrics and constraints. 
The objective function evaluates a combination of metrics and constraints to determine 
the &quot;best&quot; path for packets to follow.</p>
<h2 id="general-concepts"><a class="header" href="#general-concepts">General Concepts</a></h2>
<p>In a WSN, the <strong>neighbors</strong> of a particular node are all the nodes that can be reached via single hop radio links.
In the example below, the neighbors of node 3 are: node 1, 2, 4, and 5. </p>
<p>The <strong>parents</strong> of a node are all its neighbors that are part of a possible route to the sink node. 
In the example below the parents of node 3 are node 1 and 2. The <strong>preferred parent</strong> 
of a node is the neighbor that is on the best route from the node to the sink, such as node 1 for node 3.</p>
<p><img src="assets/rpl_intro/rpl_intro1.svg" alt="Empty RPL network" /></p>
<p>In a network using RPL, the <strong>rank</strong> of each node is a measure of its distance from the root node. 
This rank is determined using <strong>routing metrics</strong>, which include characteristics of both 
the <strong>links</strong> (such as throughput, latency, link reliability, expected transmission count, 
link quality level) and the <strong>nodes</strong> (such as energy state). 
These metrics are used in <strong>objective functions</strong> to calculate the cost of a route between nodes. </p>
<p>A <strong>RPL instance</strong> is a group of DODAGs that have the same RPL instance ID and share a common root node, 
identified by a DODAG ID. The <strong>DODAG version number</strong> is a counter that is incremented by the root node 
whenever a new version of the DODAG is created.</p>
<h2 id="control-messages-upward-and-downward-routes--modes-of-operation"><a class="header" href="#control-messages-upward-and-downward-routes--modes-of-operation">Control Messages, Upward and Downward Routes,  Modes of Operation</a></h2>
<p>The DODAG is created with the assistance of control messages, specifically ICMPv6 messages. 
The four types of control messages that RPL uses to construct the DODAG are:</p>
<p>â€¢ DODAG Information Object (DIO)</p>
<p>â€¢ Destination Advertisement Object (DAO)</p>
<p>â€¢ Destination Advertisement Object Acknowledgment (DAO-ACK)</p>
<p>â€¢ DODAG Information Solicitation (DIS).</p>
<p>RPL uses two types of routes to enable communication within a network: <strong>upward routes</strong> and <strong>downward routes</strong>. 
<strong>Upward routes</strong> are used for M2P communication and are discovered and maintained using DIO messages. 
<strong>Downward routes</strong>, on the other hand, enable P2M and P2P communication and are established using DAO messages.</p>
<p>RPL supports two modes of downward traffic: <strong>storing</strong> and <strong>non-storing</strong>. In the <strong>storing (fully stateful) mode</strong>, 
each node maintains a downward <strong>routing table</strong> and traffic travels only as far as a common parent node. 
In the <strong>non-storing (fully source routed) mode</strong>, all traffic is sent to the root node, which then uses <strong>source routes</strong> to send 
the traffic to its destination. This mode does not require each node to maintain a routing table, but it increases the dependency 
on the root node and the latency of the communication.</p>
<p>The exchange of control messages during the construction of the DODAG may vary depending on the mode of operation that is set for RPL.
In some modes of operation, some of these messages may not be sent at all. 
The mode of operation determines the specific message exchange that occurs during the construction of the DODAG.</p>
<p>There are 4 modes of operation defined in RPL standard:</p>
<p><strong>â€¢ MOP 0 = no downward routes maintained</strong></p>
<p>In this MOP, DAO messages are disabled and the DODAG only maintains upward routes. 
This means that nodes will not transmit or will ignore the DAO messages. 
However, DIO and DIS messages are still sent. In this MOP, only M2P communication is possible.</p>
<p><strong>â€¢ MOP 1 = non storing mode</strong></p>
<p>In this MOP, both upward and downward routes are supported within the DODAG. 
Thus, DIO, DIS, and DAO messages are issued. 
As this is a non-storing mode, the DAO messages are sent to the root. 
In this MOP, all three types of communication are possible: M2P, P2M, and P2P. 
However, multicast is not supported in this MOP.</p>
<p><strong>â€¢ MOP 2 = storing mode with no multicast support</strong></p>
<p>In this MOP, support is provided for both upward and downward routes within the DODAG. 
This is achieved through the issuance of DIO, DIS, and DAO messages. 
As this is a storing mode, the DAO messages are sent to the preferred parent. 
In this MOP, all three types of communication are possible: M2P, P2M, and P2P.
However, multicast is not supported in this MOP.</p>
<p><strong>â€¢ MOP 3 = storing mode with multicast support</strong></p>
<p>This MOP is similar to MOP2, but includes support for multicast. </p>
<p>The root and nodes that are already part of a DODAG advertise this MOP. 
The MOP is included in the DIO messages. 
In order to join the network, nodes must support the MOP advertised in the DIO messages, 
otherwise, they can only join the network as leaf nodes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mode-of-operation-0-no-downward-routes-maintained"><a class="header" href="#mode-of-operation-0-no-downward-routes-maintained">Mode of Operation 0: no downward routes maintained</a></h1>
<p>First, there are constrained devices (nodes) that just woke up:</p>
<p><img src="assets/rpl_mop_0/rpl0.svg" alt="Empty RPL network" /></p>
<p>Then, one node decided that he wants to join a RPL network.
For that it sends a <em>DODAG Information Solicitation (DIS)</em> message.
This message is sent to the <em>all-RPL-node</em> IPv6 multicast address (<code>ff02::a1</code>).
This means that all nodes in the radio range of the sending node will receive it.</p>
<p>In the image below, node 1 is the one that decided to join a RPL network. The root node (R) 
and nodes 2 and 3 are in its radio range. </p>
<p><img src="assets/rpl_mop_0/rpl1.svg" alt="Empty RPL network" /></p>
<p>In the begining, only the root node has information about the RPL DODAG.
Therefore, it is the only one that can respond with a <em>DODAG Information Object (DIO)</em> packet.
The root node is also using the <code>ff02::a1</code> multicast address. Thus, the <em>DIO</em> message will be received
by all the nodes in its radio range, including node 1.</p>
<p><img src="assets/rpl_mop_0/rpl2.svg" alt="Empty RPL network" /></p>
<p>The nodes that received the <em>DIO</em> message and did not yet join a RPL network
will join this network.
They do that by selecting the root node (the sender of the <em>DIO</em> packet) as their parent. 
The nodes that join the network will also set their rank. The rank is computed based on the information received 
in the <em>DIO</em> message and link/node metrics with the help of the objective function.</p>
<p><img src="assets/rpl_mop_0/rpl3.svg" alt="Empty RPL network" /></p>
<p>Because the nodes have selected a parent, they can start sending <em>DIO</em> packets as well. As stated before the <em>DIO</em> messages
are sent via the <em>all-RPL-node</em> IPv6 multicast address. This means that all the nodes in the radio range of a node will receive
the <em>DIO</em> message. When node 1 is sending the <em>DIO</em> message, the root, its current parent, will also receive it. 
The root node will ignore this message. This is because all nodes in a DODAG must ignore <em>DIO</em> messages from nodes 
with a higher rank, which guarantees optimal route selection and avoids loops.</p>
<p><img src="assets/rpl_mop_0/rpl4.svg" alt="Empty RPL network" /></p>
<h2 id="maintenance-of-a-rpl-network"><a class="header" href="#maintenance-of-a-rpl-network">Maintenance of a RPL network</a></h2>
<p>The <em>DIO</em> messages will be sent by nodes even after the DODAG is formed. The goal of sending <em>DIO</em> messages for the whole 
life of a RPL network is to maintain or upgrade the formed DODAG. However, the constant generation of control messages 
can consume a lot of energy. To preserve resources, the sending of control messages is minimized and only done when necessary,
through the use of the <strong>Trickle Timer algorithm</strong>.</p>
<p>The <strong>Trickle Timer algorithm</strong> monitors the consistency of packet exchange in the network. If the pattern is consistent 
and free of redundant or outdated data, the Trickle Timer decreases the rate of sending <em>DIO</em> messages exponentially.
However, if there are any inconsistencies in the network, the next <em>DIO</em> message is rescheduled and sent at the shortest 
possible time interval. In other words, this algorithm ensures that <em>DIOs</em> are aggressively advertised when the 
network is unstable and advertised at a slower pace when it is stable.</p>
<p>There are four parameters that control the functioning of the Trickle Timer:</p>
<p><strong>â€¢ Imin</strong>, which represents the minimum time interval between two <em>DIO</em> messages</p>
<p><strong>â€¢ Imax</strong>, which represents the maximun time interval between two <em>DIO</em> message</p>
<p><strong>â€¢ k</strong>, which represents the redundancy constant (the number of redundant control messages)</p>
<p><strong>â€¢ I</strong>, which represents the size of the current time-interval</p>
<p>At the start, <em>I</em> is set to a random value between <em>Imin</em> and <em>2 x Imin</em>. <em>DIO</em> messages are sent when <em>I</em> expires and if the
counter (c) that keeps track of the consistent received messages is smaller than <em>k</em>. 
If the network is stable, <em>I</em> is doubled until it reaches <em>Imax</em>. However, if inconsistencies are detected in the network, 
<em>I</em> is reset to a value between <em>Imin</em> and <em>2 x Imin</em>. This ensures efficient use of resources while still being able to ensure
the maintainance of the network.</p>
<h2 id="m2p-communication"><a class="header" href="#m2p-communication">M2P communication</a></h2>
<p>In <strong>MOP 0</strong>, the network is configured such that only upward routes are established. This means that 
any node in the network can transmit messages to the root node or any other node on its path towards the root, 
but not to other nodes in the network. The default route, represented by the parent of the node, is used to
transmit data packets in an upward direction. For example, node 5 can transmit messages to the root node 
or to nodes 2 and 5 (which are on the path towards the root) but cannot send messages to any other nodes within the network.</p>
<p><img src="assets/rpl_mop_0/rpl5.svg" alt="Empty RPL network" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mode-of-operation-1-downward-routes-non-storing-mode"><a class="header" href="#mode-of-operation-1-downward-routes-non-storing-mode">Mode of Operation 1: downward routes (non-storing mode)</a></h1>
<p>In <strong>MOP 1</strong> the message exchange for building a network starts the same way as it does in MOP 0:
a node that wants to join a network will send a <em>DIS</em> message and the nodes that are already
part of the network will respond with a <em>DIO</em> message.</p>
<p>In <strong>MOP 1</strong> after receiving a <em>DIO</em> message and selecting the parent and setting the rank,
the node will answer with a <em>DAO</em> message. In <strong>MOP 1</strong> this message is sent to the root. 
The <em>DAO</em> message contains information about the parent of the node. The address of the 
preferred parent is transmitted in the <strong>Transit Information RPL option</strong> of the <em>DAO</em> message.</p>
<p><img src="assets/rpl_mop_1/rpl_mop1_1.svg" alt="Empty RPL network" /></p>
<p>The node receiving the <em>DAO</em> message can answer with a <em>DAO-ACK</em> message. </p>
<h2 id="p2m-and-p2p-communication"><a class="header" href="#p2m-and-p2p-communication">P2M and P2P communication</a></h2>
<p>In <strong>MOP 1</strong>, the network is configured such that both upward and downward routes are established. This means that 
the root can send data packets to the nodes in the network and that any node in the network can transmit messages to any other node. </p>
<p>When forwarding the packet upward the default route is used, until the packet is received by the root. In non-storing mode the root is the only node that has knowledge about all the children-parent relationships 
in the network. Based on this information the root adds a new header to the packet, the <strong>source
routing header (SRH)</strong>. In the address field of the SRH the path that the packet needs to follow
toward the destination is inserted.</p>
<p><img src="assets/rpl_mop_1/rpl_mop1_2.svg" alt="Empty RPL network" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mode-of-operation-2-downward-routes-storing-mode-without-multicast"><a class="header" href="#mode-of-operation-2-downward-routes-storing-mode-without-multicast">Mode of Operation 2: downward routes (storing mode, without multicast)</a></h1>
<p>In <strong>MOP 2</strong> the message exchange for building a network starts the same way as it does in MOP 0: 
a node that wants to join a network will send a <em>DIS</em> message and the nodes that are already 
part of the network will respond with a <em>DIO</em> message.</p>
<p>In <strong>MOP 2</strong> after receiving a <em>DIO</em> message and selecting the parent and setting the rank, 
the node will answer with a <em>DAO</em> message. In <strong>MOP 2</strong> this message is sent to the preferred parent. 
Based on the uinformation received through the <em>DAO</em> messages, all the nodes in the network 
will store a routing table containing information on how to reach all their descendants 
(all the nodes in their subtree). </p>
<p><img src="assets/rpl_mop_2/rpl_mop2_1.svg" alt="Empty RPL network" /></p>
<p>The node receiving the <em>DAO</em> message can answer with a <em>DAO-ACK</em> message. </p>
<h2 id="p2m-and-p2p-communication-1"><a class="header" href="#p2m-and-p2p-communication-1">P2M and P2P communication</a></h2>
<p>In <strong>MOP 2</strong>, the network is configured such that both upward and downward routes are established. This means that 
the root can send data packets to the nodes in the network and that any node in the network can transmit messages to any other node. </p>
<p>When forwarding the packet upward the default route is used, until the packet is received by a common ancestor
of the sender and receiver. The common ancestor will redirect the packet based on the information stored in its
routing table.</p>
<p><img src="assets/rpl_mop_2/rpl_mop2_2.svg" alt="Empty RPL network" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mode-of-operation-3-downward-routes-storing-mode-with-multicast"><a class="header" href="#mode-of-operation-3-downward-routes-storing-mode-with-multicast">Mode of Operation 3: downward routes (storing mode, with multicast)</a></h1>
<p>In <strong>MOP 3</strong> the message exchange for building a network starts the same way as it does in MOP 0: 
a node that wants to join a network will send a <em>DIS</em> message and the nodes that are already 
part of the network will respond with a <em>DIO</em> message.</p>
<p>In <strong>MOP 3</strong> after receiving a <em>DIO</em> message and selecting the parent and setting the rank, 
the node will answer with a <em>DAO</em> message with the address of the sender in the RPL Target Option. In <strong>MOP 3</strong> this message is sent to the preferred parent and is then propagated towards the root. If the node is part of a multicast group (node 6 in the picture below), a second <strong>DAO</strong> message is sent to the preferred parent and propagated to the root. This message will contain in the RPL Target Option the multicast group address. This allows the root to know which nodes are part of a multicast group. </p>
<p><img src="assets/rpl_mop_3/rpl_mop3_1.svg" alt="Empty RPL network" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-the-project"><a class="header" href="#about-the-project">About the project</a></h1>
<p>The goal of this project is to add the RPL protocol to the <code>smoltcp</code> Rust library.
The project is funded by <a href="https://nlnet.nl/thema/NGIAssure.html">NLnet NGI Assure</a>.
More information about the project can be found on <a href="https://nlnet.nl/project/Smoltcp/">their website</a>.</p>
<hr />
<p><img src="assets/nlnet_banner.svg" alt="NLnet" width="50%"/></p>
<p><img src="assets/ngi_assure.svg" alt="NGI Assure" width="50%"/></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
